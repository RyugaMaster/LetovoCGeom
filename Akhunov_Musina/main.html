<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../Geom.css">
        <title>
            Поиск двух ближайших точек на плоскости
        </title>
    </head>
    <body>
        <article id = "art1" Поиск двух ближайших точек на плоскости> 
            <a href = "https://www.letovo.ru" id = "img3"> <img src="https://letovo.ru/upload/img/logo.png"> </a>
            <h1>
                Поиск двух ближайших точек на плоскости
            </h1>
            <br>
            <a  href="../index.html" class = "brd"> Главная страница</a>
            <a href = "video.html" class = brd>Видео</a>
            <p>
                Нам дано множество из N точек на плоскости, и среди них надо найти две ближайшие точки. Наивное решение - перебрать всевозможные пары точек. Однако асимптотика такого алгоритма – O(N<sup>2</sup>), а мы рассмотрим алгоритм с асимптотикой O(N log<sub>2</sub> N).
            </p>
            <h2>
                Алгоритм
            </h2>
            <p>
                Для решения задачи воспользуемся методом «разделяй и властвуй». Будем делить точки на две половины и решать задачу рекурсивно для каждой из них, а далее объединять, пытаясь прорелаксировать ответ.
            </p> 
            <p>
                Отсортируем точки по X-координате. Существует два способа как можно делить точки:
                <br>
                &ensp;&ensp;&ensp;&ensp;1) По количеству, и когда их останется мало найти ответ пользуясь тривиальным алгоритмом.
                <br>
                &ensp;&ensp;&ensp;&ensp;2) По X-координате. В конце все точки будут иметь одинаковую X-координату.
                <br>
                Тогда, отсортировав все точки по y-координате, пару ближайших можно определить одним проходом по отсортированному массиву.
                Первый способ будет работать за O (N log<sub>2</sub> N), а второй - за O (N log<sub>2</sub> C), где C – максимальное значение координаты. Так как координаты можно сжать то вторую асимптотику можно свести к первой.
            </p>
            <p> 
                Опишем, как зная ответы для обеих половин, получить ответ для всего множества точек. Пусть ответы для левой и правой части равны K1 и K2. Обозначим min(K1, K2) за K, а за P – максимальную X-координату точки левой группы. Рассмотрим те точки, чье X координаты отличаются от P не более чем на K.
                Нам осталось рассмотреть только ситуации, когда одна точка принадлежат левой части, а вторая – правой, т.к. ответы внутри групп мы уже получили. Оставим только те точки, чьи X-координаты отличаются от P не более чем на K, т.к. если точка от P находится дальше, то расстояние от неё до любой точки из другой группы будет не меньше K, следовательно, ответ она улучшить не сможет.
            </p>
            <p>
                Отсортируем оставленные точки в каждой группе по Y-координате. Т.к. “честное” выполнение сортировки на каждом шаге приведет к асимптотике O(N log<sub>2</sub> N). Будем дополнительно возвращать список точек, отсортированных по нужной координате. А возвращая ответ, – сливать эти два отсортированных списка в один общий.
            </p>
            <p> 
                Проходимся по выбранным точкам. Сейчас они у нас разделены на две группы – правую и левую. Поддерживаем указатель на точку с наименьшей координатой Y. Для нее рассматриваем первые 4 точки из противоположной группы пытаясь обновить ответ. И далее удаляем эту точку (то есть сдвигаем указатель на следующий элемент с минимальным Y).
            </p>
            <h2>
                Обоснование алгоритма
            </h2>
            <p>
                Почему не нужно рассматривать более четырех точек?
            </p>
            <p>
                Пусть точка A имеет координату Y и, без ограничения общности, лежит в левой половине. Рассматривать стоит только те точки второй половины, Y-координаты которых не меньше, чем у нашей, т.к. пары точек, в которых наша точка является “верхней”, мы уже рассмотрели из “нижних” точек другой половины. А также нет смысла рассматривать точки с Y-координатой большей, чем Y + K, т.к. расстояние до них не может быть меньше K. Следовательно, все точки, которые нам необходимо рассмотреть, лежат в квадрате K*K, образованном углами [P; Y] и [P + K; Y + K]. Докажем, что в указанном квадрате не может оказаться более четырех точек. Для этого разобьем его на четыре квадрата со стороной K/2 и заметим, что если бы хоть в один из них попало хотя бы две точки, то расстояние между этими точками не превысило бы &radic;2 * K/2, что меньше K, а следовательно, ответ для данной половины оказался бы меньше K.
            </p>
            <img src="img.png" alt="Картинка не найдена" hspace = 10% vspace = 20px>
            <h2>
                Сложность
            </h2>
            <p>
                Тем самым объединение двух половин мы делаем за линейное от количества точек время. Поэтому, как раньше уже упоминалось, асимптотика полученного алгоритма будет O(N log<sub>2</sub> N). Наш алгоритм по своей работе похож на сортировку слиянием: уровней у нас log<sub>2</sub> N, а суммарное время работы всех вызовов одного уровня – линейно от общего количества точек, т.е. O(N).
            </p>
            <footer>
                    <img id = "train"  src = "http://nachalo4ka.ru/wp-content/uploads/2015/01/parovozik-3.png" alt = "Паровозик">
            </footer>
        </article>
    </body>
</html>